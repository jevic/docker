CentOS Linux release 7.2.1511 (Core) 
### 安装docker 最新版本：
# tee /etc/yum.repos.d/docker.repo <<-'EOF'
[dockerrepo]
name=Docker Repository  
baseurl=https://yum.dockerproject.org/repo/main/centos/7/  
enabled=1  
gpgcheck=1  
gpgkey=https://yum.dockerproject.org/gpg  
EOF

开启守护进程[本地和网络]
# vim /usr/lib/systemd/system/docker.service
ExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375

# sudo yum install docker-engine
# sudo systemctl enable docker
# sudo systemctl start docker
 

[root@docker ~]# docker pull centos   下载镜像
[root@docker ~]# docker info
[root@docker ~]# docker version
[root@docker ~]# docker --help
[root@docker ~]# docker images  查看镜像
[root@docker ~]# docker search [images name]  搜索镜像
[root@docker ~]# docker history [images name]  查看镜像历史版本

-i：交互式  -t: 打开一个终端 -d 后台运行 [不可同时使用] --rm 终止后立刻删除
-h hostname 指定主机名
“--restart=always” 容器自动启动参数
[root@docker ~]# docker run [--rm] [-d] -i -t centos7 /bin/bash    进入docker镜像
[root@docker ~]# cat testjob.tar |docker import - testjob
[root@docker ~]# docker ps -l 
[root@docker ~]# docker stop id
[root@docker ~]# docker start id

[root@docker ~]# docker inspect mytest   【检查容器运行状态信息】
[root@docker ~]# docker inspect -f {{   }}   ID
[root@docker ~]# docker stats testssh   【实时查看Container负载】
[root@docker ~]# docker logs -f mysql

[root@docker ~]# docker exec -it id /bin/bash  【exit退出后，容器依旧运行】
[root@docker ~]# docker attach id    进入一个容器【exit退出后，容器关闭】
[root@docker ~]# docker rm id  删除容器
[root@docker ~]# docker rmi images 删除容器


[root@docker ~]# docker ps -a | grep "Exited" | awk '{print $1 }'|xargs docker stop
[root@docker ~]# docker ps -a | grep "Exited" | awk '{print $1 }'|xargs docker rm
[root@docker ~]# docker images|grep none|awk '{print $3 }'|xargs docker rmi
清空所有异常退出后的容易，再到images删除就没有了。 
[root@docker ~]# docker rmi -f 9503b09c1a70
Deleted: 9503b09c1a707d29b084e18aa13ef5d66f43672e41dce4db5931cbf2a754daa1




5. 保存对容器的修改（commit）
当你对某一个容器做了修改之后（通过在容器中运行某一个命令），可以把对容器的修改保存下来，这样下次可以从保存后的最新状态运行该容器。
# 保存对容器的修改; -a, --author="" Author; -m, --message="" Commit message
docker ps -l 查看ID
[root@docker ~]# docker commit ID new_image_name
Note:image相当于类，container相当于实例，不过可以动态给实例安装新软件，然后把这个container用commit命令固化成一个image


[root@docker ~]# docker rm $(docker ps -q -a)    #删除所有运行的容器

---->>>
将容器中的文件拷贝到主机上
Usage: docker cp CONTAINER:PATH HOSTPATH
[root@docker ~]# docker cp testip:/tmp/testaa /tmp


--->>> 磁盘调整：
[root@docker sysconfig]# cat /etc/sysconfig/docker-storage|tail -1
DOCKER_STORAGE_OPTIONS='--storage-opt dm.no_warn_on_loop_devices=true'
指定容器默认分配的磁盘大小    >>>>  "--storage-opt dm.basesize=20G"

1.）查看宿主机分配的docker容器存储：
[root@docker ~]# ls /dev/mapper/docker-253\:0-102573667-*
/dev/mapper/docker-253:0-102573667-1e18182099ba7e7e5f63c3f3e3fd785fa77c000a424de1420dbaf3410c094977

2.）查看docker容器使用的存储空间：
[root@1e18182099ba ~]# df -h|head -3
Filesystem            Size  Used Avail Use% Mounted on
rootfs                100G  383M  100G   1% /
/dev/mapper/docker-253:0-102573667-1e18182099ba7e7e5f63c3f3e3fd785fa77c000a424de1420dbaf3410c094977

3.）查看容器扇区信息
# dmsetup table docker-253:0-102573667-1e18182099ba7e7e5f63c3f3e3fd785fa77c000a424de1420dbaf3410c094977     
0 209715200 thin 253:3 189
4.）第二个数字是设备的大小，表示有多少个512bytes扇区，
[root@docker ~]# echo $((100*1024*1024*1024/512))   << 100G 所占用的扇区
209715200

4.） 修改卷信息表
[root@docker ~]# echo $((150*1024*1024*1024/512))  << 调整为150G
314572800
[root@docker ~]# echo 0 314572800 thin 253:3 189|dmsetup load docker-253:0-102573667-1e18182099ba7e7e5f63c3f3e
3fd785fa77c000a424de1420dbaf3410c094977
[root@docker ~]# dmsetup resume docker-253:0-102573667-1e18182099ba7e7e5f63c3f3e3fd785fa77c000a424de1420dbaf34
10c094977
修改文件系统大小：
[root@docker ~]# resize2fs /dev/mapper/docker-253:0-102573667-1e18182099ba7e7e5f63c3f3e3fd785fa77c000a424de142
0dbaf3410c094977


		
##旧版本-->略过此处				   
[root@docker ~]# docker run centos /bin/echo hello   #出现警告
Usage of loopback devices is strongly discouraged for production use. Either use `--storage-
opt dm.thinpooldev` or use `--storage-opt dm.no_warn_on_loop_devices=true` to suppress this warning.
hello
[root@docker ~]# vim /etc/sysconfig/docker-storage   #编辑此文件添加下列参数即可！！
DOCKER_STORAGE_OPTIONS="--storage-opt dm.no_warn_on_loop_devices=true"
[root@docker ~]# docker restart docker


【私有仓库构建】
# docker run -d -p 5000:5000 registry  
-v <src>:<dest> [Bind mount a volume] 将上传的镜像放到/opt/data/registry
docker run -d -p 5000:5000 -v /opt/data/registry:/tmp/registry registry


-p:指定容器启动后docker上运行的端口映射，第一个为主机端口第二个为容器里的端口
[root@docker ~]# docker run -d -p 80:80 -p 8022:22 centos/lamp
自启动容器：
docker run -d --restart=always --name test centos:7 /bin/bash


--->>>>>
桥接网络：
方法一：
[root@docker ~]# systemctl stop docker
[root@docker ~]# ifconfig docker0 down 
[root@docker ~]# brctl delbr docker0
[root@docker ~]# yum install -y bridge-util
[root@docker ~]# cd /etc/sysconfig/network-script/{手动创建修改br0和eth0}
[root@docker ~]# cat /etc/sysconfig/docker-network
DOCKER_NETWORK_OPTIONS="-b=br0"


方法二：
[root@docker ~]# systemctl stop docker
[root@docker ~]# ip link set dev docker0 down
[root@docker ~]# brctl delbr docker0
[root@docker ~]# brctl addbr br0
[root@docker ~]# ip link set dev br0 up
[root@docker ~]# ip addr add 192.168.152.88/24 dev br0
[root@docker ~]# ip addr del 192.168.152.19/24 dev eth0
[root@docker ~]# ip route del default
[root@docker ~]# ip route add default via 192.168.152.1 dev br0
[root@docker ~]# ip route list 
[root@docker ~]# cat /etc/sysconfig/docker-network
DOCKER_NETWORK_OPTIONS="-b=br0"
[root@docker ~]# git clone https://github.com/jpetazzo/pipework
[root@docker ~]# cp /pipework/pipework /usr/local/bin/
[root@docker ~]# systemctl start docker
[root@docker ~]# docker run -itd --net=none --name=test1 centos:7 /bin/bash
[root@docker ~]# pipework br0 centos:7 192.168.1.100/24@192.168.1.1


方法三[网络连接为DHCP]：
[root@docker ~]# systemctl stop docker
[root@docker ~]# systemctl disable NetworkManager
[root@docker ~]# systemctl stop NetworkManager
[root@docker ~]# ifconfig docker0 down
[root@docker ~]# brctl delbr docker0
[root@docker ~]# virsh iface-bridge eth0 br0
[root@docker ~]# cat /etc/sysconfig/docker-network
DOCKER_NETWORK_OPTIONS="-b=br0"
[root@docker ~]# git clone https://github.com/jpetazzo/pipework
[root@docker ~]# cp /pipework/pipework /usr/local/bin/
[root@docker ~]# systemctl start docker
[root@docker ~]# docker run -itd --net=none --name=test1 centos:7 /bin/bash
[root@docker ~]# pipework br0 centos:7 192.168.1.100/24@192.168.1.1
Docker 使用 OpenvSwitch 网桥


save 【持久化镜像】导入导出：
[root@docker ~]# docker save centos:7 > /home/save.tar
[root@docker ~]# docker load < /home/save.tar
export【持久化容器】导入导出：
[root@docker ~]# docker export [id] > [imagesname.tar]   导出镜像
[root@docker ~]# cat /home/export.tar | docker import - busybox-1-export:latest


Docker提供了一个非常强大的命令diff，它可以列出容器内发生变化的文件和目录。
这些变化包括添加（A-add）、删除（D-delete）、修改（C-change）。
该命令便于Debug，并支持快速的共享环境。
[root@docker ~]# docker diff container


远程路径导入：
[root@docker ~]# docker import http://example.com/test.tar


---> docker数据卷
创建一个数据卷挂载到容器的/webapp目录：
# docker run -it -d --name test -v /webapp docker.io/centos:7 /bin/bash
挂载一个主机目录作为数据卷[默认读写(rw),可以指定为只读(ro)]：
docker run -it --name=test1 -v /opt/webapp:/opt/webapp centos7:ip /bin/bash
挂载本地主机文件作为数据卷：[记录容器输入的历史]
docker run -rm -d /root/.bash_history:/.bash_history centos7 /bin/bash

数据卷容器：
1.> 创建数据卷容器：
# docker run -itd -v /mydata --name=volumes1 centos:6.8

2.> 创建容器，并从volumes1容器中挂载数据卷
# docker run -itd --volumes-from=volumes1 --volume-driver=/mydata --name votest1 centos:6.8
# docker run -itd --volumes-from=volumes1 --volume-driver=/mydata --name votest2 centos:6.8
3.>> 三个容器共享/mydata数据卷，都可以读写

注意：数据卷容器自身(volumes)并不需要保持运行状态！即使删除容器db1,db2，数据卷容器mydata里面的数据依旧存在；



iptables -t nat -A PREROUTING -p tcp -m tcp --dport 90 -j DNAT --to-destination 172.17.0.2:80
/sbin/iptables -t nat -A DOCKER -p tcp -d 0/0 --dport 5000 -j DNAT --to-destination 192.168.152.1:5000 ! -i br0


容器互联：
<在两个互联的容器之间创建了一个安全隧道，而且不用映射它们的端口到宿主机，避免暴漏数据库端口到外部网络上>
--link
docker run -d -P  --name=name --link container_name:alias images_name <Command>
docker run -d -P --name=web --link mysql:db centos:7 /bin/bash


docker 【本地和网络】守护进程：
CentOS7: --->>> Docker1.10
root@Mini ~]# cat /etc/sysconfig/docker|egrep -v "^#|^$"   环境变量配置文件！
OPTIONS='--selinux-enabled --log-driver=journald'
DOCKER_CERT_PATH=/etc/docker
DOCKER_OPTS=‘-H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375'

[root@Mini ~]# cat /usr/lib/systemd/system/docker.service
ExecStart=/usr/bin/docker-current daemon $DOCKER_OPTS \
          --exec-opt native.cgroupdriver=systemd \
          $OPTIONS \
          ........
[root@Mini ~]# systemctl daemon-reload
[root@Mini ~]# systemctl restart docker
[root@Mini ~]# netstat -tnlp|grep docker;ps -ef|grep docker
tcp6       0      0 :::2375                 :::*                 LISTEN      2917/docker-current
root       2917   1  0 12:23 ?        00:00:00 /usr/bin/docker-current daemon -H tcp://0.0.0.0:2375 --exec-opt native.cgroupdriver=systemd --selinux-enabled --log-driver=journald


Ubuntu:
root@docker:~# cat /etc/default/docker|egrep -v "^$|^#"
DOCKER_OPTS="-H unix:///var/run/docker.sock -H 0.0.0.0:2375"


Docker CGruop 组限制项：
root@jay:/sys/fs/cgroup/memory/docker# pwd
/sys/fs/cgroup/memory/docker
root@jay:/sys/fs/cgroup/memory/docker# cd ..
root@jay:/sys/fs/cgroup/memory# cd ..
root@jay:/sys/fs/cgroup# ls
blkio      cpu      cpu,cpuacct  devices  hugetlb  net_cls           net_prio    pids
cgmanager  cpuacct  cpuset       freezer  memory   net_cls,net_prio  perf_event  systemd
root@jay:/sys/fs/cgroup#



